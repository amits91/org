* UPF Power Models: Empowering your power intent specification
** Abstract
*** Whats the problem?
**** Complex Socs with large number of IPs
**** IPs have sophisticated power management resulting in lot of power intent code
**** Large code introduces bugs
**** Integration of IPs becomes a challenge
*** Whats in this paper?
**** A methodology of expressing power intent based on UPF power models
*** How that addresses the problem?
*** Demonstrate the solution
Todays low power SoCs use large number of low power IPs with their own UPF describing the power intent. 
The enormous size and number of IPs poses serious problems in IP integration and increased compilation times. 
To add to that file handling of various IP UPFs also become a challenge in environments with large IPs. 
In this paper, we define a methodology using standard UPF Power Models which empowers user to significantly improve the compilation speeds and alleviate the file management problems. 
The use of Power Models will ensure the correct by construction of UPF for the IPs by leveraging the standard checks defined by the UPF itself. 
It will enable reduction in the size of power intent by leveraging standard UPF constructs to automate integration of IPs.

** Challenges with traditional approach
*** File Management
**** A large number of IPs with their own UPF files become a file management issue.
*** IP Management
**** Ensure the same UPF is used for all instances of an IP.
**** Users have to load the UPF file for every instances of an IP.
**** IP integration may un-intentionally modify the power management of an IP, this needs to be protected
***** As IP was verified using specific power management
*** Bottom-up & Top-down specification
**** UPF needs to be partitioned into standalone blocks so that it can be implemented at a block level.
**** The partitioned UPF needs to be used in an SoC environment and semantics should not be affected
*** Self-contained UPF
**** UPF needs to be self contained so that it contains sufficient power management information for block level implementation
**** There is a need for consistent semantics when the self contained UPF is loaded in the bigger environment
*** Protected environment
- Complex IPs depend on various conditional constructs which use Tcl variables. When the IP UPFs get instantiated in a big environment, often it becomes a problem that values of the Tcl variables are unintentionally set from previous invocation
- hence it is important 
*** Ease of use
*** Enable tool optimizations
*** Scopewise specification
**** Tedius
**** Anything can be modified and hence tools cant assume self-contained
** How Power Models addresses
*** How power models address this problem? 
*** Leverages LRM's builtin checks to ensure self contained UPF
*** Empower tools to optimize the UPF processing
*** Enable better file management and IP management by defining libraries
** Use case and methodology
** Conclusion
*** Power Models provide ease of writing UPF
*** Provide a protected environment
*** Ensure users UPF is correct by construct leveraging LRM checks/semantics and avoids unintended misuse
*** reduces codesize and empowers automation due to inbuilt semantics
